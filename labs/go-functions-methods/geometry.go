// Copyright Â© 2016 Alan A. A. Donovan & Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 156.

// Package geometry defines simple types for plane geometry.
//!+point
package main

import (
	"fmt"
	"math"
	"math/rand"
	"os"
	"strconv"
	"time"
)

const (
	min = -100.0
	max = 100.0
)

// Point in space.
type Point struct{ x, y float64 }

// X getter.
func (p Point) X() float64 {
	return p.x
}

// Y getter
func (p Point) Y() float64 {
	return p.y
}

// Distance traditional function
func Distance(p, q Point) float64 {
	return math.Hypot(q.X()-p.X(), q.Y()-p.Y())
}

// Distance but as a method of the Point type
func (p Point) Distance(q Point) float64 {
	return math.Hypot(q.X()-p.X(), q.Y()-p.Y())
}

//!-point

//!+path

// A Path is a journey connecting the points with straight lines.
type Path []Point

// Distance returns the distance traveled along the path.
func (path Path) Distance(sidesDistance []float64) float64 {
	sum := 0.0
	for i := range path {
		if i > 0 {
			d := path[i-1].Distance(path[i])
			sum += d
			sidesDistance[i-1] = d
		}
	}
	d := path[len(path)-1].Distance(path[0])
	sidesDistance[len(sidesDistance)-1] = d
	sum += d
	return sum
}

// CheckSegment verifies points p, q, r, checks if q is between p and r.
func CheckSegment(p, q, r Point) bool {
	xAxis := q.X() <= math.Max(p.X(), r.X()) && q.X() >= math.Min(p.X(), r.X())
	yAxis := q.Y() <= math.Max(p.Y(), r.Y()) && q.Y() >= math.Min(p.Y(), r.Y())
	return xAxis && yAxis
}

// CheckOrientation checks if the points are colinear, clockwise or counterclockwise.
func CheckOrientation(p, q, r Point) int {
	// Orientation of 3 points
	val := (q.Y()-p.Y())*(r.X()-q.X()) - (q.X()-p.X())*(r.Y()-q.Y())
	if val == 0 {
		return 0 // Colinear
	} else if val > 0 {
		return 1 // Clockwise
	}
	return 2
}

// CheckIntersection checks if the two lines generated by 2 points intersect, based on the solution of:
// https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
func CheckIntersection(p1, q1, p2, q2 Point) bool {
	o1 := CheckOrientation(p1, q1, p2)
	o2 := CheckOrientation(p1, q1, q2)
	o3 := CheckOrientation(p2, q2, p1)
	o4 := CheckOrientation(p2, q2, q1)

	if o1 != o2 && o3 != o4 {
		return true
	}

	// Special cases
	if o1 == 0 && CheckSegment(p1, q2, q1) {
		return true
	} else if o2 == 0 && CheckSegment(p1, q2, q1) {
		return true
	} else if o3 == 0 && CheckSegment(p2, p2, q2) {
		return true
	} else if o4 == 0 && CheckSegment(p2, q1, q2) {
		return true
	}

	return false
}

// FixIntersection ensures that all points the given array are not intersecting.
func FixIntersection(points []Point) {
	l := len(points)
	if l == 3 {
		for CheckSegment(points[0], points[1], points[2]) {
			points[0] = GetRandomPoint()
			points[1] = GetRandomPoint()
			points[2] = GetRandomPoint()
		}
		return
	}
	for i := 0; i < l-3; i++ {
		if CheckIntersection(points[i], points[i+1], points[i+2], points[i+3]) {
			points[i] = GetRandomPoint()
			points[i+1] = GetRandomPoint()
			points[i+2] = GetRandomPoint()
			points[i+3] = GetRandomPoint()
			i = 0
		}
	}
}

// GetRandomPoint gets a random point between min and max.
func GetRandomPoint() Point {
	x := rand.Float64()*(max-min) + min
	y := rand.Float64()*(max-min) + min
	return Point{x, y}
}

func main() {
	args := os.Args
	if len(args) > 1 {
		i, err := strconv.Atoi(args[1])
		if err != nil {
			fmt.Printf("Not a valid number of sides specified, got [%s]\n", args[1])
			return
		}
		if i < 3 {
			fmt.Printf("Not a valid number of sides, must be above or equal to 3, got [%d]\n", i)
			return
		}
		points := make([]Point, i)
		rand.Seed(time.Now().UTC().UnixNano())
		for i := range points {
			points[i] = GetRandomPoint()
		}
		FixIntersection(points)
		fmt.Printf("- Generating a [%d] sides figure\n", i)
		fmt.Printf("- Figure's vertices\n")
		for i := range points {
			fmt.Printf("  - (%.2f, %.2f)\n", points[i].X(), points[i].Y())
		}
		sidesDistance := make([]float64, i)
		perimeter := Path(points).Distance(sidesDistance)
		fmt.Printf("- Figure's Perimeter\n")
		fmt.Print("  - ")
		for i := range sidesDistance {
			if i < len(sidesDistance)-1 {
				fmt.Printf("%.2f + ", sidesDistance[i])
			} else {
				fmt.Printf("%.2f = ", sidesDistance[i])
			}
		}
		fmt.Printf("%.2f\n", perimeter)

	} else {
		fmt.Println("Not enough arguments, please enter sides. Example: ./geometry 2")
	}
}

//!-path
